% Created 2016-09-15 tor 14:09
\documentclass[11pt]{article}
\usepackage[backend=biber,citestyle=authoryear,style=alphabetic]{biblatex}
\bibliography{PaperTools/bibtex/jp.bib}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage{fontspec}
\usepackage{unicode-math}
\setmonofont{DejaVu Sans Mono}
\setmainfont[]{DejaVu Sans}
\newcommand{\case}[3][]{\mathsf{case}_{#1} #2 \mathsf{of} \{#3\}^m_{k=1}}
\newcommand{\inl}{\mathsf{inl} }
\newcommand{\inr}{\mathsf{inr} }
\newcommand{\flet}[1][]{\mathsf{let}_{#1} }
\newcommand{\fin}{ \mathsf{in} }
\newcommand{\susp}[1]{⟦#1⟧}
\author{Jean-Philippe Bernardy and Arnaud Spiwack}
\date{\today}
\title{Linear and unrestricted at the same time}
\hypersetup{
 pdfauthor={Jean-Philippe Bernardy and Arnaud Spiwack},
 pdftitle={Linear and unrestricted at the same time},
 pdfkeywords={},
 pdfsubject={},
 pdflang={English}}
\begin{document}

\maketitle
%% \tableofcontents
\begin{abstract}
  \noindent This article introduces and describes a presentation of a
  linearly-typed lazy programming language which is designed to be
  integrate well with an existing programming language, in particular
  in GHC/Haskell.
\end{abstract}

\setcounter{tocdepth}{1}
\tableofcontents

%% In this note we give an overview of a lambda calculus augmented with
%% weights on variable (bindings). We argue briefly that the calculus is
%% a generalisation of both:
%% \begin{itemize}
%% \item the simply-typed lambda calculus and
%% \item the linear lambda calculus
%% \end{itemize}
%% %
%% Additionally, we give
%% \begin{itemize}
%% \item an operational semantics which demonstrates how memory
%%   management of linear values can be simplified.
%% \item example types for a number of simple programs
%% \item a brief comparison with alternative approaches to linearity
%%   (tracking linearity in types; session types)
%% \end{itemize}

\section{Statics}
\label{sec:orgheadline8}
\subsection{Weights}
\label{sec:orgheadline1}

The set of weights is the two-element set $\{1,ω\}$. Intuitively, 1
represents \emph{exactly one} instance, while $ω$ represents any
number of instances (at the discretion of the consumer, and possible
zero).  The metasyntactic variables \(π\) and \(ρ\) range over this
set. Weights are equipped with + and $·$ operations:


\begin{align*}
1 · ω = ω \\
ω · 1 = ω \\
ω · ω = ω \\
1 · 1 = 1
\end{align*}

\begin{align*}
1 + ω &= ω \\
ω + 1 &= ω \\
1 + 1 &= ω \\
ω + ω &= ω
\end{align*}

We equip weights with a partial order (written \(· ≤ ·\)) such that \(1 ≤ ω\).

\emph{(An alternative which may be worth pursuing is to choose the set of
weights to be \(ℕ∪{ω}\), in which case \(1+1=2\).)}

\subsection{Types}
\label{sec:orgheadline2}

We propose a variant of the simply typed λ-calculus where the types
are:

\begin{itemize}
\item a weighted arrow: \(A →_π B\) (you can get a \(B\) if you can provide a
quantity \(π\) of \(A\)). Consequently:
\begin{itemize}
\item \(A →_ω B\) is the intuitionistic arrow (\(A → B\))
\item \(A →_1 B\) is the linear arrow (\(A ⊸ B\))
\end{itemize}
\item weighted ADTs:
\begin{align*}
\mathsf{data} D = \left(c_k  π₁ A₁  …  π_{n_k} A_{n_k}\right)^m_{k=1}
\end{align*}
(\(D\) has \(m\) constructors \(c_k\), for \(k ∈ 1…m\)).

Note the following special cases:
\begin{itemize}
\item The type data Pair a b = Pair ωa ωb is isomorphic to the intuitionistic product (a×b)
\item The type data Tensor a b = Pair 1a 1b is isomorphic to the linear tensor product (a⊗b)
\item The type data Bang a = Box ωa is isomorphic to the exponential (!a)
\end{itemize}
\end{itemize}

The syntax of types and type declarations is as follows ($c$ ranges over constructor names):
\begin{align*}
  W &::= πA &\text{weight-annotated type}\\
  γ &::= c  \vec{W}&\text{constructor declaration}\\
  decl &::= \mathsf{data } D = \vec{γ}&\text{data type declaration}\\
  A,B &::=\\
      & |  A →_π B &\text{function type}\\
      & |  D &\text{data type}
\end{align*}

\subsection{Terms}
\label{sec:orgheadline3}

The syntax for terms is:

\begin{align*}
e,s,t,u & ::= \\
    & |  x & \text{variable} \\
    & |  λx. t & \text{abstraction} \\
    & |  t_π s & \text{application} \\
    & |  c t₁ … t_n & \text{data construction} \\
    & |  \case[ρ] t {c_k  x₁ … x_{n_k} → u_k}  & \text{case} \\
    & |  \flet x =_{π₁} … x =_{π_n} t_n \fin u & \text{let}
\end{align*}

Remark: we often omit the weight $π$ in an application, because it is
usually obvious from the context.

\subsection{Contexts}
\label{sec:orgheadline6}

Every variable binding in a context is equipped with a weight,
additionally to the type:

\begin{align*}
  Γ,Δ & ::=\\
    & |  x :_π A, Γ & \text{weight-annotated binder} \\
    & |     & \text {empty context}
\end{align*}

\subsubsection{Context addition}
\label{sec:orgheadline4}

We define a context addition, written \(Γ+Δ\), as follows.

\begin{itemize}
\item When a variable appears on both input contexts, we add the weights in
the result:

\((x :_ρ A,Γ) + (x :_π A,Δ) = x :_{ρ+π} A, (Γ+Δ)\)

\item otherwise we propagate:

\((x :_ρ A,Γ) + Δ = x :_ρ A, Γ+Δ\)   \hfill   \(x ∉ Δ\)
\end{itemize}


\subsubsection{Context scaling}
\label{sec:orgheadline5}

Contexts can be scaled by a weight:

\begin{displaymath}
ρ(x :_π A, Γ) =  x :_{πρ} A, ρΓ
\end{displaymath}

\subsection{Typing rules}
\label{sec:orgheadline7}

We have a typing judgement \(Γ ⊢ t : A\), inductively defined by the
following rules.  The intuition behind this judgement is: can
construct \emph{one} value $t$ of type $A$ from $Γ$. We do not define
a judgement to denote that we can construct a quantity $ρ$
of type $A$; instead we will use $ρΓ ⊢ t : A$ to indicate this
situation.

\begin{mathpar}

\inferrule{ }{ωΓ + x :_ρ A ⊢ x : A}\text{variable}

\inferrule{Γ, x :_{π} A  ⊢   t : B}
          {Γ ⊢ λx. t  :  A  →_π  B}\text{abs}

\inferrule{Γ ⊢ t :  A →_π B  \\   πΔ ⊢ u : A}
          {Γ+πΔ ⊢ t_π u  :  B}\text{app}

\inferrule{πᵢΔᵢ ⊢ tᵢ : Aᵢ \\ \text {$c_k$ is a constructor of $D$ with arguments $Aᵢ$ and weights $πᵢ$}}
          {\sum_i πᵢΔᵢ ⊢ c_k  t₁ … t_n :  D}\text{constructor}

\inferrule{ρΓ   ⊢  t  : D  \\ Δ, x₁:_{ρπᵢ} Aᵢ, …, x_{n_k}:_{ρπ_{n_k}} A_{n_k} ⊢ u_k : C \\ \text{with each $c_k$ as above}}
          {ρΓ+Δ ⊢ \case[ρ] t {c_k  x₁ … x_{n_k} → u_k} : C}\text{case}


\inferrule{πᵢΓᵢ   ⊢  tᵢ  : Aᵢ  \\ Δ, x₁:_{π₁} A₁ …  x_n:_{π_{n}} A_n ⊢ u : C }
          { Δ+\sum_i πᵢΓᵢ ⊢ \flet x =_{π₁} t₁  …  x =_{π_n} t_n  \fin u : C}\text{let}


\end{mathpar}

Lemmas:
\begin{enumerate}
\item if \(Γ ⊢ t : A\) then \(ωΓ ⊢ t : A\).
\item erasure of weights preserves typing
\end{enumerate}

\subsection{Examples of simple programs and their types}

\hspace{-4cm}\begin{minipage}{\textwidth}
\begin{align*}
map & : (A ⊸ B) → [A] ⊸ [B] & \text{Scales well in unrestricted contexts}\\
lmap & : (A ⊸ B) → f A ⊸ f B & \text{Guaranteeing that no element is lost} \\
λx. λy. x & : A ⊸ B → A \\
          & : A → B → A \\
λ(f,x). f x & : \{f :_1 A ⊸ B, x :_1 A\} ⊸ B & \text{(using a row type for concision)}\\
            & : \{f :_1 A → B, x :_ω A\} ⊸ B \\
            & : \{f :_1 A →_π B, x :_π A\} ⊸ B & \text{most general type} \\
λf. λg. λx. f (g x) & : (B → C) → (A → B) → A → C \\
                    & : (B → C) ⊸ (A → B) → A → C & \text {always better: comp uses $f$  only once} \\
                    & : (B ⊸ C) ⊸ (A → B) ⊸ A → C & \text {if $f$ is linear, then $g$ is used only once} \\
                    & : (B ⊸ C) ⊸ (A ⊸ B) ⊸ A ⊸ C & \text {if $g$ is linear too then $x$ is used only once} \\
                    & : ∀ π ρ. (B →_π C) ⊸ (A →_ρ B) →_π A →_{πρ} C & \text{most general type} \\
\end{align*}
\end{minipage}

%% TODO: additional examples: copy (from linear to unrestricted), free, more?

If we want the most general types of higher order functions, we need
explicit quantification over weights. Still, this is somewhat simpler
than what Morris presents in ``The best of both worlds'', because we
do not need bounded quantification. Instead we use multiplication of
weights. (There is also the possibility to add a subtyping relation as
a middle ground.)

%% TODO: example of ill-typed programs due to linearity violation,
%% with tentative error messages.

\section{Impact on GHC type system}
\label{sec:ghc}

\subsection{Primops}
\subsection{FFI}


\section{Dynamics}
\label{sec:orgheadline16}

The semantics given in this section demonstrate a further extension of
Haskell enabled by linear types: prompt deallocation of thunks. Such
an extension of the run-time system is not necessary to benefit from
linear types as was demonstrated in~\label{sec:ghc}. However, this
dynamic semantics can also help give confidence in the correctness of
the extensions of~\label{sec:ghc}.

\subsection{(Extended) Launchbury semantics}
\label{sec:orgheadline11}

\subsubsection{Translation}
\label{sec:orgheadline9}
As in \textcite{launchbury_natural_1993}, we translate from terms to
terms where values are always bound to variables. 


\begin{align*}
(λx. t)^* &= λx. (t)^* \\
x^*       &= x \\
  (t_π  x )^* &= (t)^*_π  x \\
  (t_π  u )^* &= \flet y =_{π} (u)^* \fin (t)^*_π  y \\
c_k  t₁ … t_n &= \flet x₁ =_{π_1} (t₁)^*,…, x_n =_{π_n} (t_n)^* \fin c_k x₁ … x_n \\
(\case t {c_k  x₁ … x_{n_k} → u_k})^* &= \case {(t)^*} {c_k  x₁ … x_{n_k} → (u_k)^*} \\
(\flet x =_{π₁} t₁  …  x =_{π_n} t_n \fin u)^* & = \flet x₁ =_{π_1} (t₁)^*,…, x_n =_{π_n} (t_n)^* \fin (u)^*
\end{align*}

\subsubsection{Natural semantics}
Compared to Launchbury:

\begin{itemize}
\item we add a linear heap, ranged over by Φ,Ψ,Ξ.
  (GC'ed heap is ranged over by Γ,Δ,Θ);
\item We add a weight in the reduction relation, corresponding to the
  quantity of values to produce.
\item The rules for \emph{variable} and \emph{let} are changed to
  account for weights.
\end{itemize}

The weight in the reduction relation is used to interpret $\flet =1 …$
bindings into allocations on the proper heap.  Indeed, in ω contexts,
$\flet =1 …$ must allocate on the GC heap, not on the linear
one. Indeed, consider the example:

\begin{verbatim}
let f =_ω (λy :_1 (). case y of () -> let z =_1 True in z) in
let a =_ρ f ()
\end{verbatim}

The function \texttt{f} creates some data. When run in a linear context, \texttt{f}
allocates \texttt{f} on the linear heap. When run in an unrestricted context, it
must allocate \texttt{z} on the GC heap. So, its behaviour depends the value of ρ.

\begin{mathpar}
\inferrule{ }{Γ;Φ : λx. e ⇓_ρ Γ;Φ : λx. e}\text{abs}


\inferrule{Γ;Φ : e ⇓_ρ Δ;Ψ : λy.e' \\  Δ;Ψ : e'[x/y] ⇓_{πρ} Θ;Ξ : z}
           {Γ;Φ : e_π x ⇓_ρ Θ;Ξ : z} \text{application}

\inferrule{Γ;Φ : e  ⇓_ω  Δ;Ψ : z}{(Γ,x ↦ e;Φ) : x ⇓_ρ (Δ;x ↦ z;Ψ) : z}\text{unrestricted variable}


\inferrule{Γ;Φ : e ⇓_1 Δ;Ψ : z}
{(Γ;Φ,x ↦ e) : x ⇓_1 Δ;Ψ : z}\text{linear variable}


\inferrule{(Γ,x_i ↦ e_i;Φ,x_j ↦ e_j) : e ⇓_ρ Δ;Ψ : z}
{Γ;Φ : \flet x₁ =_{π₁} e₁ … x_n =_{π_n} e_n \fin e ⇓_ρ Δ;Ψ : z}\text{let}

\text{where $i$ ranges over the subset of indices such that $πᵢρ$ = ω,}

\text{and $j$ ranges over the subset such that $π_jρ$ = 1.}


\inferrule{ }{Γ;Φ : c  x₁ … x_n ⇓_ρ Γ;Φ : c  x₁ … x_n}\text{constructor}


\inferrule{Γ;Φ: e ⇓_ρ Δ,Ψ: c_k  x₁ … x_n \\   Δ,Ψ :  e_k[xᵢ/yᵢ] ⇓_ρ Θ;Ξ :  z}
   {Γ;Φ :  \case e {c_k  y₁ … y_n ↦ e_k } ⇓_ρ Θ;Ξ :  z}\text{case}
\end{mathpar}

Remark: the \emph{unrestricted variable} rule also triggers when the
weight is 1, thus effectively allowing linear variables to look on the
GC heap. This behaviour allows an occurence of a linear variable to
work in an unrestricted contexts, in turn justifying the $1 + ω = ω$
rule.

\paragraph{Theorem: The GC heap contains no references to the linear heap}
(This result is critical for heap consistency.)

Lemmas:
\begin{itemize}
\item If the weight is ω, then the linear heap is empty.
%  A
% consequence of this is that we should have main ::1 IO () --
% otherwise it's impossible to have anything in the linear heap.

% Furthermore, in order to use IO in any reasonable way, we need a
% 'linear do notation'.
\item Every variable which is bound in the linear heap is statically
  bound with weight 1.
\item Corrollary: every variable bound statically with weight ω is
  bound in the GC heap.
\end{itemize}


% Proof:
% 1. The only place where the heap is populated is in let. So we check let. We put things in the GC heap when πρ = ω.
%    a. π = ω. Statically, the expression can only depend on the ω context, so we can't create any reference to the linear heap.
%    b. ρ = ω. In this case, by lemma 1. the linear heap is empty, and thus it's impossible to link to anything in it.

% relation: Δ|Γ;Φ ⊢ e :_ρ A   ≜  Δ ⊢ letω Γ in let1 Φ in e :_ρ A

% theorem: if Γ;Φ : e ⇓_ρ Δ,Ψ : z then ∀Ξ,Θ,Α.   Θ|Γ;(Φ-Ξ) ⊢ e :_ρ A  ⇒  Θ|Δ;(Ψ-Ξ) ⊢ z :_ρ A


% unrestricted variable case:

% Need to prove:

%   Θ,x:T|Γ;(Φ-Ξ) ⊢ e :_ρ T  ⇒  Θ,x:T|Δ;(ψ-Ξ) ⊢ z :_ρ T
% ──────────────────────────────────────────────────────
%  Θ|Γ,x↦e;(Φ-Ξ) ⊢ x :_ρ T  ⇒  Θ|Δ,x↦z;(ψ-Ξ) ⊢ z :_ρ T

% case case:

% Need to prove:

% Ψ = free vars ek - y + x + Z
% ? = free vars ek - y

% Σ|Γ;Φ-(Z+?) ⊢ e :_ρ D ⇒ Σ|Δ;Ψ-(Z+?) ⊢ ck x :_ρ D
% Σ|Δ;Ψ-Z ⊢ ek[x/y] :_ρ A ⇒ Σ|θ;Ξ-Z ⊢ z :_ρ A
% ─────────────────────────────────────────────────────────────
% Σ|Γ;Φ-Z ⊢ case e of {ck y -> ek} :_ρ A  ⇒ Σ|Θ,Ξ-Z ⊢ z :_ρ A



Yet, the following example may, at first glance, look like a counter
example where \verb|x| is in the non-GC heap while \verb|y| is in the
GC-heap and points to \verb|x|:
\begin{verbatim}
data () = ()

let x =_1 ()
let y =_ω ( case x of { () -> () })
in ()
\end{verbatim}
However, while \verb|()| can indeed be typed as $⊢ () :_ω ()$, the
typing rule for 'case' gives the same weight to the case-expression as
a whole as to the scrutinee (\verb|x| in this case). Therefore
\verb|case x of { () -> ()}| has weight 1.

Remark: for a program to turn a 1-weight into an ω-weight, one may use
the following definition:
\begin{verbatim}
data Bang A = Box ωA
\end{verbatim}
The expression \verb|case x of { () -> Box ()}| has type
\verb|Bang A|, but still with weight 1.  The programming pattern described above does not apply
just to the unit type $()$, but to any data type \verb|D|. Indeed, for such
a type we will have a function \verb|D ⊸ Bang D| (this may be even
efficiently implemented by copying a single pointer --- for example if
we have a single array, or a notion of compact region).  Thus at any
point where we have an intermediate result comprised of data only, we
may switch to use the linear heap. In a second phase, this data may
then be moved to the GC heap and used for general consumption.

In that light, the only way to use a linear value from the GC-heap is
to force it first, and then chain computations with \verb|case| --- for
example as follows:
\begin{verbatim}
let x =_1 ()
case ( case x of { () -> Box () }) of {
  Box y -> ()
}
\end{verbatim}
This still does not create a pointer from GC-heap to non-GC heap: by the
time \verb|y| is created, the linear value \verb|x| has been freed.

If, on the other hand, \verb|x| had weight $ω$, then we would be in the
usual Haskell case, and the following expression does type:
\begin{verbatim}
let x =_ω ()
let y =_ω ( case x of { () -> () } )
in ()
\end{verbatim}

If one wants to use the linear heap 'locally', one must use CPS.

That is:

\begin{verbatim}
doSomethingWithLinearHeap :: (A ⊸ Bang B) ⊸ A ⊸ (B → C) ⊸ C
doSomethingWithLinearHeap f x k = case f x of
  Box y -> k y

doSomethingWithLinearHeap :: Bang B ⊸ (B → C) ⊸ C
doSomethingWithLinearHeap x k = case x of
  Box y -> k y
\end{verbatim}

\section{Comparison with other techniques}

\subsection{Linearity as a property of types vs. linearity as a property of bindings (variables)}

In several presentations (\cite{wadler_linear_1990,mazurak_lightweight_2010,morris_best_2016}
programming languages incorporate
linearity by dividing types into two kinds. A type is either linear
or unrestricted. Unrestricted types typically includes primitive types
(\texttt{Int}), and all (strictly positive) data types. Linear types
include typically resources, effects, etc.

A characteristic of this presentation is that linearity ``infects''
every type containing a linear type. Consequently, if we want to make
a pair of (say) an integer and an effect, the resulting type must be
linear. This property means that polymorphic data structure can no
longer be used ``as is'' to store linear values. Technically, one
cannot unify a type variable of unrestricted kind to a linear
type. One can escape the issue by having polymorphism over kinds;
unfortunately to get principal types one must have subtyping between
kinds and bounded polymorphism.

In contrast, we have automatic scaling of linear types to unrestricted
ones in unrestricted contexts. This feature already partially
addresses the problem of explosion of types. In order to get principal
types we need quantification over weights, and extension of the
language of weights to products and sums.

Another issue with the ``linearity in types'' presentation is that it
is awkward at addressing the problem of ``simplified memory
management'' that we aim to tackle. As we have seen, the ability to
use an intermediate linear heap rests on the ability to turn a linear
value into an unrestricted one. When linearity is captured in types,
we must have two versions of every type that we intend to move between
the heaps. Even though it is possible to provide this, it is somewhat
annoying to duplicate every primitive type. (Possibly we could
prescribe \#Int to be linear, but this may break lots of existing
programs.)

\subsection{Session types vs. linear types}

\Textcite{wadler_propositions_2012} provides a good explanation of
the relation between session types vs. linear types (even though the
paper contains some subtle traps --- notably the explanation of par
and tensor in LL does not match the semantics given later.). In sum,
session types classify 'live' sessions with long-lived channels, whose
type ``evolves'' over time. In contrast, linear types are well suited
to giving types to a given bit of information. One can see thus that
linear types are better suited for a language based on a lambda
calculus, while session types are better suited for languages based on
a pi-calculus and/or languages with effects. Or put another way,
it's a matter of use cases: session types are particularly well-suited
to naturally describe communication protocols, while linear types are
well suited for describing data. One is communication centric. The
other is data centric. Yet there is a simple
encoding from session types to linear types (as Wadler demonstrates).

\printbibliography
\end{document}


% TODOs:
% - have a single heap (with weights)
% - explain data T = C 1A wB means C :: A ⊸ B → T
% - give types for primops (and semantics?)
% - talk about thunk freeing themselves
% - underline that two aspects are mostly independent:
% 1. prompt deallocation of cons cels
% 2. resource management with explicit free
% - examples with wrong usage
% Operational meaning for
% f : A → B
% f : A ⊸ B 
% that is: an input with static weight 1 can have dynamic weight w

