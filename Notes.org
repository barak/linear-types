* Local linear things

** Old
One would linke to construct a function which allows to locally use
the linear heap. We attempt:

> extract :: Bang A ⊸ A
> extract (Bang x) = x


The above is correct but not too helpful, because when `u` is linear, then
`extract u` will provide a single instance of A.

The GC-oriented reason for this is that the computation of `extract
u` may be suspended, and this would create pointers from the
GC-heap to the linear heap. A value of type `Bang A` is a pointer
to the linear heap, though, so once a whnf is computed it is safe
to extract.

We need a sequentialisation operator. We already have one: Bang
elimination.

> seq_extract :: Bang A ⊸ (A → B) ⊸ B
> seq_extract (Box x) f = f x

Programming with `seq_extract` means sequentialising explicitly
non-linear computations inside of linear computations. It is hard
to introduce intermediate computation which would benefit from the
linear execution model as part of a computation (like a monad,
linearity will leak out of functions and be exposed in its type)


We want to be able to write functions such as the following, in
which putting the result in the GC wouldn't force to do every
intermediate computation in the GC.

> withHeap :: (Heap ⊸ Bang A) ⊸ A

To achieve that we need a primitive with the following type:

   ωΓ ⊢ u ::_1 !A
------------------------------
ωΓ ⊢ strong_extract u ::_ω A

It is important that all variables in the context are unrestricted,
otherwise this could cause pointers from thunks in the GC-heap to
the linear heap. The simplest way to understand the semantics of
`strong_extract` is to translate programs with `strong_extract` to
programs of regular linear logic in CPS, where `strong_extract` is
translated to `seq_extract`. Open: what is the best way to
introduce this primitive in the language?


The CPS translation turns the omega into continuations, but
leaves 1 in direct style. Roughly:

for a term t :_ω A we have ⟦t⟧ :_1 (A → k) ⊸ k


⟦strong_extract u⟧ k = seq_extract u k
⟦t u⟧ k = ⟦u⟧ (⟦t⟧ k)
…


translation of linear things leaves everything untouched except
application:

tω u = ⟦u⟧ t
…


The above suggests the primitive:


kind_of_call/cc :: ((A → ⊥) ⊸ ⊥) → A
** New

We can interpret the expression 

case1 t of Bang x -> u[x]

specially. That is, even in ω contexts, t can be evaluated just
once. (We'll get ω things out of the Bang anyway.)

* Weight Polymorphism 


A ::= ∀ρ. A


t ::= λπ. t | t p

p,q ::= 1 | ω | p+q | p·q


        Γ ⊢ t : A    π fresh for Γ
  ----------------------------------- weight abs
          Γ ⊢ λπ. t : ∀π. A


         Γ ⊢ t : ∀π. A
   ----------------------------------- weight app
         Γ ⊢ t p : A[p/π]



 Γ ⊢ t[π] : A[π]    π fresh for Γ
-----------------------------------
  Γ ⊢ λπ.t : ∀π. A
---------------------------------------
    Γ ⊢ (λπ.t) p : A[p/π]


reduces to


  Γ ⊢ t[p/π] : A[p/π]


Unfortunately we can't really assume that the user will write weight
applications, so we must infer those.
* Subtyping

weights are really intervals. We have thus:
[1..1] ⊆ [0..ω]

but the subtyping relation works the other way, so
ω ⊂ 1

the usual subtyping rule:
B ⊂ B'  A' ⊂ A  π'⊂π
----------------------
A ->π B  ⊂ A' ->π' B'

and so:

  A ⊸ B  ⊂  A -> B

In words: if you expect 1, I can give you ω. So, if you expect an
unrestricted function, I can give you a linear function.


* Copying
for a program to turn a $1$-weight into an $ω$-weight, one may use
the following definition:
\begin{code}
data Bang A = Bang ωA
\end{code}

The expression |case x of { () -> Bang ()}| has type
|Bang A|, but still with weight 1.  The programming pattern described above does not apply
just to the unit type $()$, but to any data type |D|. Indeed, for such
a type we will have a function |D ⊸ Bang D| (this may be even
efficiently implemented by copying a single pointer --- for example if
we have a single array, or a notion of compact region).  Thus at any
point where we have an intermediate result comprised of data only, we
may switch to use the linear heap. In a second phase, this data may
then be moved to the GC heap and used for general consumption.

In that light, the only way to use a linear value from the GC-heap is
to force it first, and then chain computations with |case| --- for
example as follows:
\begin{code}
let x = _1 ()
case ( case x of { () -> Bang () }) of {
  Bang y -> ()
}
\end{code}
This still does not create a pointer from GC-heap to non-GC heap: by the
time |y| is created, the linear value |x| has been freed.

If, on the other hand, |x| had weight $ω$, then we would be in the
usual Haskell case, and the following expression does type:
\begin{code}
let x = _ ω ()
let y = _ ω ( case x of { () -> () } )
in ()
\end{code}

If one wants to use the linear heap 'locally', one must use CPS.

That is:

\begin{code}
doSomethingWithLinearHeap :: (A ⊸ Bang B) ⊸ A ⊸ (B → C) ⊸ C
doSomethingWithLinearHeap f x k = case f x of
  Bang y -> k y

doSomethingWithLinearHeap :: Bang B ⊸ (B → C) ⊸ C
doSomethingWithLinearHeap x k = case x of
  Bang y -> k y
\end{code}

* Safe handles.

There are several options to introduce a Handle safely:

** Linear Monads?
What should monadic bind look like?

The "root tree" is used only once, always, so we can have the type:
(>>=) :: m a -> (a -> m b) ⊸ m b

-- additionally if the reference is used once, then its action is used once too.
(>>=) :: m a ⊸ (a ⊸ m b) ⊸ m b

For many monads (IO) actions are never shared. So we probably want just the above type.
Downside: yet result is often to be shared, and this has to be explicit:

(>>=) :: m (Bang a) ⊸ (Bang a ⊸ m b) ⊸ m b

(We have syntactic sugar there anyway... so perhaps we don't care)


In this situation we may write code like

#+BEGIN_SRC haskell
do h <- openFile
   h' <- use h -- kinda ugly
   close h'
#+END_SRC

where

openFile :: String -> IO Handle
hClose :: Handle ⊸ IO ()

** Bang to prevent escape

Can use the same trick as withNewByteArray:

withFile :: FilePath -> (Handle ⊸ IO (Bang a)) -> IO a

However one may miss the advantage compared to

withFile :: FilePath -> (Handle -> IO a) -> IO a

(You have to be trying hard to use withFile incorrectly)

** Linear context

There is a single (context ::1 Context), and we provide

openFile :: FilePath -> Context ⊸ (Context ⊗ Handle)
closeFile :: (Context ⊗ Handle) ⊸ Context

Could even make a dependently-typed version to ensure that the Handle
of the file is not shared behind one's back.

roughly:

openFile :: ∀ paths. (path :: FilePath) -> Context (path:paths) ⊸ (Context paths ⊗ Handle path)
closeFile :: ∀ path paths. (Context paths ⊗ Handle path) ⊸ Context paths

* (Mutable) Array of linear variables

mkArray :: List a ⊸ Array a -- allowing for unrestricted array
withNewArray :: List a ⊸ (Array a ⊸ Bang k) ⊸ k -- ensuring that arrays are always linear.
updateArray :: Int → a ⊸ Array a ⊸ (Array a ⊗ a)
splitArray :: Int → Array a ⊸ (Array a ⊗ Array a)
foldArray :: b ⊸ (Int → a ⊸ b ⊸ b) → Array a ⊸ b
byteArraySize :: Array a → Int


* Proof of consistency for dyn. semantics

We exend the reduction with types, as follows:

   Γ:t  ⇓ρ  Δ:z
becomes:
  Ξ ⊢ (Γ|t ⇓ Δ|z) :ρ A, Σ

where
Ξ : free variables
Γ,Δ: heap states
t,z : term states
Σ : stack (pairs of term and type)


Then we can prove

if Ξ ⊢ (Γ|t :ρ A),Σ then Ξ ⊢ (Δ|z :ρ A),Σ

where Ξ ⊢ (Γ|t :ρ A),Σ  ≝   Ξ ⊢ let Γ in (t,terms(Σ)) : (A⊗types(Σ))

Consistency of the heap is implied by well-typedness; so if we start
with a well-typed heap, we will obtain a consistent heap.


The rules are:

  Ξ, x:ωB ⊢ (Γ|e ⇓ Δ|z) :ρ A, Σ
---------------------------------------------------------------- shared variable
  Ξ ⊢ (Γ,x :ω B = e | x  ⇓ Δ, x :ω B = z | z) :ρ A, Σ



  Ξ,x:1B ⊢ (Γ|e ⇓ Δ|z) :1 A, Σ
----------------------------------------------------- linear variable
  Ξ ⊢ (Γ,x :1 B = e| x  ⇓  Δ|z) :1 A,  Σ



  Ξ ⊢ (Γ,    x :ρq B = e1 |  t ⇓ Δ|z) :ρ A, Σ
---------------------------------------------------------- let
  Ξ ⊢ (Γ|let x :q B  = e1 in t ⇓ Δ|z) :ρ A,  Σ



    Ξ  ⊢  (Γ|e      ⇓ Δ|λy.u):ρ A →q B, x:qρ A, Σ
    Ξ  ⊢  (Δ|u[x/y] ⇓ Θ|z)   :ρ A →q B,         Σ
------------------------------------------------------------------ app
    Ξ  ⊢  (Γ|e x ⇓ Θ|z) :ρ B ,Σ


  Ξ,y:pqρ A ⊢ (Γ|e ⇓ Δ|c x) :qρ D, u:ρ C, Σ
  Ξ ⊢ (Δ|u[x/y] ⇓ Θ|z) :ρ C, Σ
------------------------------------------------------------------- case
  Ξ ⊢ (Γ|case[q] e of {c y ↦ u} ⇓ Θ|z) :ρ C, Σ


TODO: case1  Bang


** Small step version


  Γ,z ↦ let x :q B  = e1 in t :ρ A  ⊢ z,Σ   ⟶   Γ,x :qρ B  = e1, z ↦ t ⊢ z:ρ A,Σ
  Γ,z ↦ e x ⊢ z,Σ                           ⟶   Γ,z' ↦ e ⊢ z' ,x :qρ A,Σ
  Γ,z ↦ λy. u ⊢ z,x,Σ                       ⟶  Γ,z' ↦ u[x/y] ⊢ z',Σ

This is ugly and should be polarized.
